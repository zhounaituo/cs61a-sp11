- 书
	- [ ] 过程抽象
		- [ ] 程序的构成元素
			- [ ] 表达式
			- [ ] 命名，环境
			- [ ] 组合求值
			- [ ] 复合过程
			- [ ] 程序中的替换模型
			- [ ] 条件表达式，判定语句
			- [ ] 过程的黑盒抽象
		- [ ] 过程，过程生产的过程
			- [ ] 线性递归，迭代
			- [ ] 树递归
			- [ ] 增长阶（Orders of Growth)
		- [ ] 高阶函数的形式抽象
			- [ ] 程序作为参数
			- [ ] Lambda
			- [ ] 程序作为通用方法
				- [ ] 这个通用方法指代什么？
			- [ ] 程序作为返回值
	- [ ] 数据抽象
		- [ ] 数据抽象的介绍
			- [ ] 抽象壁垒
			- [ ] 数据意味着什么？
		- [ ] 层次数据，闭包性质
			- [ ] 序列的表示
			- [ ] 层次结构
			- [ ] 序列作为常规接口
		- [ ] 符号数据
			- [ ] 引用（Quotation）
		- [ ] 抽象数据的多种表示法
			- [ ] 复杂数字的展示
			- [ ] 标记数据
			- [ ] 数据驱动编程，可加性
				- [ ] 什么是可加性？
		- [ ] 泛函数系统（System with Generic Operations）
			- [ ] 泛计算函数
			- [ ] 不同类型数据的组合
	- [ ] 模块化，对象，状态
		- [ ] 赋值和本地状态（Assignment and Local State）
			- [ ] 本地状态的变量
			- [ ] 引入赋值的好处
			- [ ] 引入赋值的成本
		- [ ] 求值环境模型
			- [ ] 求值的规则
			- [ ] 简单函数的应用
			- [ ] 作为本地状态存储的框架
			- [ ] 内部定义
		- [ ] 可变数据模型
			- [ ] 可变链表结构
			- [ ] 队列的表示
			- [ ] 表的表示（tables）
			- [ ] 模拟数字电路
			- [ ] 约束的传播
		- [ ] 并发：时间至关重要
			- [ ] 并发系统里的自然时间
			- [ ] 并发控制的机制
		- [ ] 流
			- [ ] 流是延迟列表
			- [ ] 无限流
			- [ ] 开发流范式
			- [ ] 函数式编程的模块和面向对象的模块
	- [ ] 元抽象（Metalignuistic Abstraction）
		- [ ] 元求值器
			- [ ] 求值器的核心
			- [ ] 表达式的表示
			- [ ] 求值器的数据结构
			- [ ] 求值器作为程序运行
			- [ ] 数据作为程序
			- [ ] 内部定义
			- [ ] 将句法分许和执行分离
		- [ ] Scheme的变体：懒求值器
			- [ ] 常规顺序和应用顺序
			- [ ] 懒求值的解释器
			- [ ] 流作为懒列表（Streams as Lazy Lists）
		- [ ] Scheme的变体：非确定性计算
			- [ ] Amb and Search
			- [ ] amb 求值器的实现
		- [ ] 逻辑编程
			- [ ] 演绎信息检索
			- [ ] 检索系统是如何工作的
			- [ ] 逻辑编程是数学逻辑吗？
			- [ ] 实现检索系统
				- [ ] 驱动循环和实例化
				- [ ] 求值器
				- [ ] 通过模式匹配查询断言
				- [ ] 规则和统一
				- [ ] 维护数据库
				- [ ] 流操作
				- [ ] 检索语法函数
				- [ ] 框架和绑定
	- [ ] 使用内存进行计算（Computing with Register Machines）
- CS61a
	- [ ] 函数式编程
	- [ ] 高阶函数（Procedures）
	- [ ] 递归和迭代
	- [ ] 数据抽象，序列
	- [ ] 层次数据，Scheme 解释器
	- [ ] 泛算子（Generic Operators）
	- [ ] 面向对象编程
	- [ ] 局部状态变量，环境
	- [ ] 可变数据，队列，表
	- [ ] 客户端-服务端模型，并行计算
	- [ ] 流
	- [ ] 元循环求值器（Metacircular evaluator）
	- [ ] 分析求值器
	- [ ] 懒求值器，非确定性求值器
	- [ ] 逻辑编程
- 提问
	- 过程于函数的区别？